import { app, BrowserWindow, ipcMain, dialog } from 'electron';
import fs from 'fs';
import path from 'path';
import Store from 'electron-store';
import ignore from 'ignore';
import { Worker } from 'worker_threads';
import { exec, spawn } from 'child_process';
import { promisify } from 'util';
import {
  getLanguageFromFileName,
  TEXT_EXTENSIONS,
  LANGUAGE_EXTENSION_MAP,
} from './constants/languages';

const execAsync = promisify(exec);

// TypeScript interface for file tree nodes
interface FileTreeNode {
  id: string;
  name: string;
  parentPath: string;
  path: string;
  isDirectory: boolean;
  children: FileTreeNode[];
  childrenLoaded: boolean;
  isLoading: boolean;
  isExpanded: boolean;
  level: number;
}

// Background loading progress interface
interface BackgroundLoadProgress {
  totalDirectories: number;
  loadedDirectories: number;
  currentPath: string;
  isComplete: boolean;
}

// Git interfaces
interface GitFileStatus {
  path: string;
  status: 'modified' | 'added' | 'deleted' | 'renamed' | 'untracked';
  staged: boolean;
}

interface GitStatus {
  files: GitFileStatus[];
  branch: string;
  ahead: number;
  behind: number;
  isClean: boolean;
}

interface GitBranchInfo {
  current: string;
  remote?: string;
  ahead: number;
  behind: number;
}

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

const SELECTED_FOLDER_STORE_NAME = 'selected-folder';
const store = new Store();

// Global reference to main window
let mainWindow: BrowserWindow | null = null;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

// Ultra-fast single level loader for instant response
const buildSingleLevelTreeAsync = async (
  dirPath: string,
): Promise<FileTreeNode[]> => {
  try {
    const items = await fs.promises.readdir(dirPath, { withFileTypes: true });

    // Quick separation and basic sort
    const directories = items
      .filter(item => item.isDirectory())
      .sort((a, b) => a.name.localeCompare(b.name));
    const files = items
      .filter(item => !item.isDirectory())
      .sort((a, b) => a.name.localeCompare(b.name));

    return [...directories, ...files].map(item => {
      const itemPath = path.join(dirPath, item.name);
      const node: FileTreeNode = {
        id: itemPath,
        name: item.name,
        parentPath: dirPath,
        path: itemPath,
        isDirectory: item.isDirectory(),
        children: [],
        childrenLoaded: false, // Will be loaded later
        isLoading: false,
        isExpanded: false,
        level: 0,
      };
      return node;
    });
  } catch (error) {
    console.error(`Error reading directory: ${dirPath}`, error);
    return [];
  }
};

// Fast async version for initial loading (optimized for speed)
const buildInitialFileTreeAsync = async (
  dirPath: string,
  maxDepth: number = 2,
  currentDepth: number = 0,
): Promise<FileTreeNode[]> => {
  try {
    // Use async readdir for non-blocking I/O
    const items = await fs.promises.readdir(dirPath, { withFileTypes: true });

    // Process directories and files separately for better performance
    const directories: fs.Dirent[] = [];
    const files: fs.Dirent[] = [];

    // Pre-sort by separating directories and files (faster than full sort)
    for (const item of items) {
      if (item.isDirectory()) {
        directories.push(item);
      } else {
        files.push(item);
      }
    }

    // Simple name-only sort (faster than locale compare for initial load)
    directories.sort((a, b) => (a.name < b.name ? -1 : 1));
    files.sort((a, b) => (a.name < b.name ? -1 : 1));

    const allItems = [...directories, ...files];
    const nodes: FileTreeNode[] = [];

    // Process items in batches to avoid blocking
    const batchSize = 20;
    for (let i = 0; i < allItems.length; i += batchSize) {
      const batch = allItems.slice(i, i + batchSize);

      // Process batch
      for (const item of batch) {
        const itemPath = path.join(dirPath, item.name);
        const node: FileTreeNode = {
          id: itemPath,
          name: item.name,
          parentPath: dirPath,
          path: itemPath,
          isDirectory: item.isDirectory(),
          children: [],
          childrenLoaded: currentDepth < maxDepth,
          isLoading: false,
          isExpanded: false,
          level: currentDepth,
        };

        // For directories within depth limit, load children asynchronously
        if (item.isDirectory() && currentDepth < maxDepth) {
          try {
            node.children = await buildInitialFileTreeAsync(
              itemPath,
              maxDepth,
              currentDepth + 1,
            );
            node.childrenLoaded = true;
          } catch (error) {
            console.warn(`Cannot read directory: ${itemPath}`, error);
            node.children = [];
            node.childrenLoaded = true;
          }
        }

        nodes.push(node);
      }

      // Yield control after each batch to prevent blocking
      if (i + batchSize < allItems.length) {
        await new Promise(resolve => setImmediate(resolve));
      }
    }

    return nodes;
  } catch (error) {
    console.error(`Error reading directory: ${dirPath}`, error);
    return [];
  }
};

// Helper function to load immediate children only (for lazy loading)
const loadDirectoryChildren = (dirPath: string): FileTreeNode[] => {
  try {
    const items = fs.readdirSync(dirPath, { withFileTypes: true });

    return items
      .sort((a, b) => {
        // Directories first, then files, alphabetically
        if (a.isDirectory() && !b.isDirectory()) return -1;
        if (!a.isDirectory() && b.isDirectory()) return 1;
        return a.name.localeCompare(b.name);
      })
      .map(item => {
        const itemPath = path.join(dirPath, item.name);
        const node: FileTreeNode = {
          id: itemPath,
          name: item.name,
          parentPath: dirPath,
          path: itemPath,
          isDirectory: item.isDirectory(),
          children: [],
          childrenLoaded: false, // These will need to be loaded later if expanded
          isLoading: false,
          isExpanded: false,
          level: 0, // Will be set properly when integrated into the tree
        };
        return node;
      });
  } catch (error) {
    console.error(`Error reading directory: ${dirPath}`, error);
    return [];
  }
};

// Background function to load complete tree structure (non-blocking)
const loadCompleteTreeBackground = async (
  rootPath: string,
  onProgress?: (progress: BackgroundLoadProgress) => void,
): Promise<FileTreeNode[]> => {
  const startTime = Date.now();
  let totalDirectories = 0;
  let loadedDirectories = 0;

  // First pass: count total directories for progress tracking
  const countDirectories = (dirPath: string): number => {
    try {
      const items = fs.readdirSync(dirPath, { withFileTypes: true });
      let count = 0;

      for (const item of items) {
        if (item.isDirectory()) {
          // Skip common directories that we don't want to load
          if (
            item.name.startsWith('.') ||
            item.name === 'node_modules' ||
            item.name === 'dist' ||
            item.name === 'build' ||
            item.name === 'coverage' ||
            item.name === 'target' ||
            item.name === 'bin' ||
            item.name === 'obj' ||
            item.name === '__pycache__'
          ) {
            continue;
          }

          count += 1;
          const itemPath = path.join(dirPath, item.name);
          count += countDirectories(itemPath);
        }
      }
      return count;
    } catch (error) {
      return 0;
    }
  };

  console.log('üîÑ Starting background tree loading...');
  totalDirectories = countDirectories(rootPath);
  console.log(`üìä Total directories to load: ${totalDirectories}`);

  // Recursive function to load complete tree with progress updates
  const loadTreeRecursive = async (
    dirPath: string,
    currentLevel: number = 0,
  ): Promise<FileTreeNode[]> => {
    try {
      const items = fs.readdirSync(dirPath, { withFileTypes: true });

      const nodes: FileTreeNode[] = [];

      for (const item of items) {
        const itemPath = path.join(dirPath, item.name);

        // Skip hidden files and common build directories
        if (
          item.name.startsWith('.') ||
          item.name === 'node_modules' ||
          item.name === 'dist' ||
          item.name === 'build' ||
          item.name === 'coverage' ||
          item.name === 'target' ||
          item.name === 'bin' ||
          item.name === 'obj' ||
          item.name === '__pycache__'
        ) {
          continue;
        }

        const node: FileTreeNode = {
          id: itemPath,
          name: item.name,
          parentPath: dirPath,
          path: itemPath,
          isDirectory: item.isDirectory(),
          children: [],
          childrenLoaded: false,
          isLoading: false,
          isExpanded: false,
          level: currentLevel,
        };

        // For directories, recursively load children
        if (item.isDirectory()) {
          try {
            loadedDirectories++;

            // Report progress every 10 directories or on significant milestones
            if (
              loadedDirectories % 10 === 0 ||
              loadedDirectories === totalDirectories
            ) {
              onProgress?.({
                totalDirectories,
                loadedDirectories,
                currentPath: itemPath,
                isComplete: loadedDirectories === totalDirectories,
              });
            }

            // Yield control periodically to prevent blocking
            if (loadedDirectories % 50 === 0) {
              await new Promise(resolve => setImmediate(resolve));
            }

            node.children = await loadTreeRecursive(itemPath, currentLevel + 1);
            node.childrenLoaded = true;
          } catch (error) {
            console.warn(`Cannot read directory: ${itemPath}`, error);
            node.children = [];
            node.childrenLoaded = true;
          }
        }

        nodes.push(node);
      }

      return nodes.sort((a, b) => {
        // Directories first, then files, alphabetically
        if (a.isDirectory && !b.isDirectory) return -1;
        if (!a.isDirectory && b.isDirectory) return 1;
        return a.name.localeCompare(b.name);
      });
    } catch (error) {
      console.error(`Error reading directory: ${dirPath}`, error);
      return [];
    }
  };

  const result = await loadTreeRecursive(rootPath);
  const duration = Date.now() - startTime;

  console.log(
    `‚úÖ Background tree loading completed: ${loadedDirectories} directories in ${duration}ms`,
  );

  // Send final progress update
  onProgress?.({
    totalDirectories,
    loadedDirectories,
    currentPath: rootPath,
    isComplete: true,
  });

  return result;
};

// Enhanced IPC handler for loading children with 2-level deep loading
ipcMain.handle('load-directory-children', async (event, dirPath: string) => {
  try {
    console.log('Loading children for:', dirPath, '(immediate children only)');
    // Load only immediate children for lazy loading
    const children = loadDirectoryChildren(dirPath);
    return children;
  } catch (error) {
    console.error('Error loading directory children:', error);

    // Ensure we return a proper error message, not an Event object
    const errorMessage =
      error instanceof Error
        ? error.message
        : typeof error === 'string'
        ? error
        : 'Unknown error loading directory children';

    throw new Error(errorMessage);
  }
});

// IPC handler to get background loading status
ipcMain.handle('get-background-loading-status', async () => {
  try {
    // @ts-ignore
    const folderData = store.get(SELECTED_FOLDER_STORE_NAME);

    if (!folderData) {
      return { isLoading: false, hasFolder: false };
    }

    return {
      isLoading: folderData.backgroundLoading || false,
      hasFolder: true,
      failed: folderData.backgroundLoadingFailed || false,
      folderName: folderData.name,
      folderPath: folderData.root,
    };
  } catch (error) {
    console.error('Error getting background loading status:', error);
    return { isLoading: false, hasFolder: false, error: true };
  }
});

// Set up IPC handlers
ipcMain.handle('get-folder', async () => {
  // @ts-ignore
  return store.get(SELECTED_FOLDER_STORE_NAME);
});

ipcMain.handle('open-folder', async () => {
  try {
    if (!mainWindow) {
      console.error('No main window available');
      return null;
    }

    const result = await dialog.showOpenDialog(mainWindow, {
      properties: ['openDirectory'],
      title: 'Select Directory',
    });

    console.log('Dialog result:', result);

    if (result.canceled || !result.filePaths || result.filePaths.length === 0) {
      console.log('Dialog was cancelled or no paths selected');
      return null;
    }

    const selectedPath = result.filePaths[0];
    console.log('Selected path:', selectedPath);

    // Load first level instantly for immediate UI response
    console.log('‚ö° Loading first level (ultra-fast)...');
    const startTime = Date.now();
    const singleLevelTree = await buildSingleLevelTreeAsync(selectedPath);
    const singleLevelTime = Date.now() - startTime;
    console.log(`üöÄ First level loaded in ${singleLevelTime}ms`);

    // Return single-level structure immediately for instant UI response
    const initialStructure = {
      name: path.basename(selectedPath),
      root: selectedPath,
      tree: singleLevelTree,
      backgroundLoading: true,
    };

    // Store the initial structure
    // @ts-ignore
    store.set(SELECTED_FOLDER_STORE_NAME, initialStructure);

    // Immediately start loading second level and then background loading
    setImmediate(async () => {
      try {
        // Load 2 levels for better initial tree
        console.log('üìÅ Loading 2 levels (async)...');
        const twoLevelStart = Date.now();
        const twoLevelTree = await buildInitialFileTreeAsync(
          selectedPath,
          2,
          0,
        );
        const twoLevelTime = Date.now() - twoLevelStart;
        console.log(`‚úÖ Two levels loaded in ${twoLevelTime}ms`);

        // Update with 2-level tree
        const updatedStructure = {
          name: path.basename(selectedPath),
          root: selectedPath,
          tree: twoLevelTree,
          backgroundLoading: true,
        };

        // @ts-ignore
        store.set(SELECTED_FOLDER_STORE_NAME, updatedStructure);

        // Notify renderer of the 2-level update
        if (mainWindow && !mainWindow.isDestroyed()) {
          mainWindow.webContents.send('tree-initial-update', {
            rootPath: selectedPath,
            tree: twoLevelTree,
          });
        }

        // Now start complete background loading
        console.log('üöÄ Starting complete background loading...');
        const completeTree = await loadCompleteTreeBackground(
          selectedPath,
          (progress: BackgroundLoadProgress) => {
            // Send progress updates to renderer
            if (mainWindow && !mainWindow.isDestroyed()) {
              mainWindow.webContents.send('tree-loading-progress', {
                rootPath: selectedPath,
                progress,
              });
            }
          },
        );

        // Update stored structure with complete tree
        const completeStructure = {
          name: path.basename(selectedPath),
          root: selectedPath,
          tree: completeTree,
          backgroundLoading: false, // Background loading completed
        };

        // @ts-ignore
        store.set(SELECTED_FOLDER_STORE_NAME, completeStructure);

        // Notify renderer that complete tree is ready
        if (mainWindow && !mainWindow.isDestroyed()) {
          mainWindow.webContents.send('tree-loading-complete', {
            rootPath: selectedPath,
            tree: completeTree,
          });
        }

        console.log('üéâ Background tree loading completed and stored');
      } catch (error) {
        console.error('‚ùå Background tree loading failed:', error);

        // Notify renderer of the error
        if (mainWindow && !mainWindow.isDestroyed()) {
          mainWindow.webContents.send('tree-loading-error', {
            rootPath: selectedPath,
            error: error instanceof Error ? error.message : 'Unknown error',
          });
        }

        // Update structure to indicate background loading failed
        const errorStructure = {
          name: path.basename(selectedPath),
          root: selectedPath,
          tree: singleLevelTree, // Keep the initial single-level tree
          backgroundLoading: false,
          backgroundLoadingFailed: true,
        };

        // @ts-ignore
        store.set(SELECTED_FOLDER_STORE_NAME, errorStructure);
      }
    });

    // Return initial structure immediately for instant UI response
    return initialStructure;
  } catch (error) {
    console.error('Error in open-folder handler:', error);
    return null;
  }
});

ipcMain.handle('open-file-or-folder', async () => {
  try {
    if (!mainWindow) {
      console.error('No main window available');
      return null;
    }

    const result = await dialog.showOpenDialog(mainWindow, {
      properties: ['openFile', 'openDirectory'],
      title: 'Select File or Directory',
    });

    console.log('File/Folder dialog result:', result);

    if (result.canceled || !result.filePaths || result.filePaths.length === 0) {
      console.log('Dialog was cancelled or no paths selected');
      return null;
    }

    const selectedPath = result.filePaths[0];
    console.log('Selected path:', selectedPath);

    // Check if the selected path is a file or directory
    const stats = fs.statSync(selectedPath);

    if (stats.isFile()) {
      // Handle file opening
      const content = fs.readFileSync(selectedPath, 'utf8');
      const fileName = path.basename(selectedPath);
      const fileExtension = path.extname(selectedPath).toLowerCase();

      // Use centralized language mapping
      const language = LANGUAGE_EXTENSION_MAP[fileExtension] || 'plaintext';

      return {
        type: 'file',
        file: {
          path: selectedPath,
          name: fileName,
          content: content,
          language: language,
        },
      };
    } else if (stats.isDirectory()) {
      // Handle directory opening with fast async background loading
      console.log('‚ö° Loading initial 2 layers (fast async)...');
      const startTime = Date.now();
      const initialTree = await buildInitialFileTreeAsync(selectedPath, 2, 0);
      const loadTime = Date.now() - startTime;
      console.log(`‚úÖ Initial tree loaded in ${loadTime}ms`);

      const structure = {
        name: path.basename(selectedPath),
        root: selectedPath,
        tree: initialTree,
        backgroundLoading: true,
      };

      // Store the initial structure
      // @ts-ignore
      store.set(SELECTED_FOLDER_STORE_NAME, structure);

      // Start background loading of complete tree (non-blocking)
      console.log('üöÄ Starting background loading of complete tree...');
      setImmediate(async () => {
        try {
          const completeTree = await loadCompleteTreeBackground(
            selectedPath,
            (progress: BackgroundLoadProgress) => {
              // Send progress updates to renderer
              if (mainWindow && !mainWindow.isDestroyed()) {
                mainWindow.webContents.send('tree-loading-progress', {
                  rootPath: selectedPath,
                  progress,
                });
              }
            },
          );

          // Update stored structure with complete tree
          const completeStructure = {
            name: path.basename(selectedPath),
            root: selectedPath,
            tree: completeTree,
            backgroundLoading: false,
          };

          // @ts-ignore
          store.set(SELECTED_FOLDER_STORE_NAME, completeStructure);

          // Notify renderer that complete tree is ready
          if (mainWindow && !mainWindow.isDestroyed()) {
            mainWindow.webContents.send('tree-loading-complete', {
              rootPath: selectedPath,
              tree: completeTree,
            });
          }

          console.log('üéâ Background tree loading completed and stored');
        } catch (error) {
          console.error('‚ùå Background tree loading failed:', error);

          // Notify renderer of the error
          if (mainWindow && !mainWindow.isDestroyed()) {
            mainWindow.webContents.send('tree-loading-error', {
              rootPath: selectedPath,
              error: error instanceof Error ? error.message : 'Unknown error',
            });
          }

          // Update structure to indicate background loading failed
          const errorStructure = {
            name: path.basename(selectedPath),
            root: selectedPath,
            tree: initialTree,
            backgroundLoading: false,
            backgroundLoadingFailed: true,
          };

          // @ts-ignore
          store.set(SELECTED_FOLDER_STORE_NAME, errorStructure);
        }
      });

      return {
        type: 'folder',
        folder: structure,
      };
    }

    return null;
  } catch (error) {
    console.error('Error in open-file-or-folder handler:', error);
    return null;
  }
});

// New IPC handler for reading file contents
ipcMain.handle('read-file', async (event, filePath: string) => {
  let result = null;

  try {
    console.log('Reading file:', filePath);

    // Validate input
    if (!filePath || typeof filePath !== 'string') {
      throw new Error('Invalid file path provided');
    }

    // Check if file exists and is readable
    const stats = await fs.promises.stat(filePath).catch(statError => {
      throw new Error(`Cannot access file: ${statError.message}`);
    });

    if (!stats.isFile()) {
      throw new Error('Path is not a file');
    }

    const maxFileSize = 10 * 1024 * 1024; // 10MB

    // Read file content with explicit error handling
    const content = await fs.promises
      .readFile(filePath, 'utf8')
      .catch(readError => {
        throw new Error(`Cannot read file content: ${readError.message}`);
      });

    const fileName = path.basename(filePath);
    const language = getLanguageFromFileName(fileName);

    result = {
      path: filePath,
      name: fileName,
      content,
      language,
    };

    // Validate result object before returning
    if (
      !result.path ||
      !result.name ||
      typeof result.content !== 'string' ||
      !result.language
    ) {
      throw new Error('Invalid file data structure');
    }

    console.log(
      'File read successfully:',
      fileName,
      `(${content.length} chars, ${language})`,
    );
    return result;
  } catch (error) {
    console.error('Error reading file:', filePath, error);

    // Ensure we throw a proper Error object, not an Event
    const errorMessage =
      error instanceof Error
        ? error.message
        : typeof error === 'string'
        ? error
        : 'Unknown error reading file';

    const finalError = new Error(`Failed to read file: ${errorMessage}`);

    // Log the error for debugging
    console.error('Final error being thrown:', finalError.message);

    throw finalError;
  }
});

// New IPC handler for saving file contents
ipcMain.handle(
  'save-file',
  async (event, filePath: string, content: string) => {
    try {
      console.log('üîÑ Starting save operation...');
      console.log('üìÅ File path:', filePath);
      console.log('üìù Content length:', content.length);
      console.log(
        'üìù Content preview (first 100 chars):',
        content.substring(0, 100),
      );

      // Validate input
      if (!filePath || typeof filePath !== 'string') {
        throw new Error('Invalid file path provided');
      }

      if (typeof content !== 'string') {
        throw new Error('Invalid file content provided');
      }

      // Create backup if file exists
      const backupPath = `${filePath}.backup`;
      try {
        if (fs.existsSync(filePath)) {
          await fs.promises.copyFile(filePath, backupPath);
          console.log('üíæ Backup created:', backupPath);
        }
      } catch (backupError) {
        console.warn('Could not create backup:', backupError);
        // Continue with save even if backup fails
      }

      // Write file content with explicit error handling
      console.log('‚úçÔ∏è Writing file...');
      await fs.promises
        .writeFile(filePath, content, 'utf8')
        .catch(writeError => {
          throw new Error(`Cannot write file content: ${writeError.message}`);
        });

      // Verify the write by reading it back immediately
      console.log('üîç Verifying write...');
      const writtenContent = await fs.promises.readFile(filePath, 'utf8');
      console.log('üìñ Written content length:', writtenContent.length);

      if (writtenContent.length !== content.length) {
        throw new Error(
          `Write verification failed: expected ${content.length} chars, got ${writtenContent.length}`,
        );
      }

      // Remove backup on successful save
      try {
        if (fs.existsSync(backupPath)) {
          await fs.promises.unlink(backupPath);
          console.log('üóëÔ∏è Backup removed');
        }
      } catch (cleanupError) {
        console.warn('Could not remove backup file:', cleanupError);
        // Don't fail the save for this
      }

      console.log(
        '‚úÖ File saved successfully:',
        filePath,
        `(${content.length} chars)`,
      );
      return { success: true, path: filePath };
    } catch (error) {
      console.error('‚ùå Error saving file:', filePath, error);

      // Ensure we throw a proper Error object
      const errorMessage =
        error instanceof Error
          ? error.message
          : typeof error === 'string'
          ? error
          : 'Unknown error saving file';

      throw new Error(`Failed to save file: ${errorMessage}`);
    }
  },
);

// New IPC handler for searching files in folder
ipcMain.handle(
  'search-in-folder',
  async (event, folderPath: string, searchQuery: string) => {
    try {
      console.log('üîç Starting search operation...');
      console.log('üìÅ Folder path:', folderPath);
      console.log('üîé Search query:', searchQuery);

      if (!folderPath || typeof folderPath !== 'string') {
        throw new Error('Invalid folder path provided');
      }

      if (!searchQuery || typeof searchQuery !== 'string') {
        throw new Error('Invalid search query provided');
      }

      const results: any[] = [];
      let totalMatches = 0;
      let searchPattern: RegExp;
      let filesSearched = 0;
      let filesSkipped = 0;

      // Create search pattern for literal text search
      try {
        // Escape special regex characters for literal search
        const escapedQuery = searchQuery.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        searchPattern = new RegExp(escapedQuery, 'gi');
      } catch (error) {
        throw new Error(`Invalid search pattern: ${error.message}`);
      }

      // Load and parse .gitignore files
      const gitignoreFilter = ignore();

      // Helper function to load gitignore files recursively
      const loadGitignoreFiles = async (dirPath: string, rootPath: string) => {
        const gitignorePath = path.join(dirPath, '.gitignore');

        try {
          if (fs.existsSync(gitignorePath)) {
            const gitignoreContent = await fs.promises.readFile(
              gitignorePath,
              'utf8',
            );
            // Add patterns relative to the root folder
            const relativePath = path.relative(rootPath, dirPath);
            const patterns = gitignoreContent
              .split('\n')
              .map(line => line.trim())
              .filter(line => line && !line.startsWith('#'))
              .map(pattern => {
                // Adjust patterns to be relative to root
                if (relativePath && !pattern.startsWith('/')) {
                  return path.posix
                    .join(relativePath, pattern)
                    .replace(/\\/g, '/');
                }
                return pattern.replace(/\\/g, '/');
              });

            gitignoreFilter.add(patterns);
            console.log(
              `üìã Loaded .gitignore from: ${gitignorePath} (${patterns.length} patterns)`,
            );
          }
        } catch (error) {}
      };

      // Load gitignore from root and traverse to find more
      await loadGitignoreFiles(folderPath, folderPath);

      // Helper function to check if a file should be ignored
      const isFileIgnored = (filePath: string): boolean => {
        const relativePath = path
          .relative(folderPath, filePath)
          .replace(/\\/g, '/');

        // Don't ignore empty paths (happens when checking root directory)
        if (!relativePath || relativePath === '.') {
          return false;
        }

        return gitignoreFilter.ignores(relativePath);
      };

      // Helper function to search in a file (optimized for performance)
      const searchInFile = async (filePath: string): Promise<any> => {
        try {
          // Check if file is gitignored
          if (isFileIgnored(filePath)) {
            console.log(
              `‚è≠Ô∏è Skipping gitignored file: ${path.relative(
                folderPath,
                filePath,
              )}`,
            );
            filesSkipped++;
            return null;
          }

          // Check file size first to avoid reading huge files
          const stats = await fs.promises.stat(filePath);
          const maxFileSize = 50 * 1024 * 1024; // 50MB limit

          if (stats.size > maxFileSize) {
            console.warn(
              `Skipping large file: ${filePath} (${stats.size} bytes)`,
            );
            filesSkipped++;
            return null;
          }

          const content = await fs.promises.readFile(filePath, 'utf8');
          const lines = content.split('\n');
          const matches: any[] = [];

          // Limit matches per file to prevent overwhelming results
          const maxMatchesPerFile = 100;
          let fileMatchCount = 0;

          for (
            let index = 0;
            index < lines.length && fileMatchCount < maxMatchesPerFile;
            index++
          ) {
            const line = lines[index];
            const lineMatches = line.match(searchPattern);
            if (lineMatches) {
              matches.push({
                lineNumber: index + 1,
                lineContent: line,
                matchCount: lineMatches.length,
              });
              fileMatchCount += lineMatches.length;
            }
          }

          if (matches.length > 0) {
            const fileMatches = matches.reduce(
              (sum, match) => sum + match.matchCount,
              0,
            );
            totalMatches += fileMatches;
            filesSearched++;

            return {
              filePath,
              fileName: path.basename(filePath),
              matches,
              totalMatches: fileMatches,
            };
          }

          filesSearched++;
          return null;
        } catch (error) {
          console.warn(`Cannot search in file: ${filePath}`, error);
          filesSkipped++;
          return null;
        }
      };

      // Helper function to recursively search directory (optimized)
      const searchDirectory = async (
        dirPath: string,
        depth: number = 0,
      ): Promise<void> => {
        // Limit search depth to prevent infinite recursion
        const maxDepth = 10;
        if (depth > maxDepth) {
          console.warn(`Max search depth reached for: ${dirPath}`);
          return;
        }

        // Check if directory itself is gitignored
        if (isFileIgnored(dirPath)) {
          console.log(
            `‚è≠Ô∏è Skipping gitignored directory: ${path.relative(
              folderPath,
              dirPath,
            )}`,
          );
          return;
        }

        // Load gitignore from current directory
        await loadGitignoreFiles(dirPath, folderPath);

        try {
          const items = await fs.promises.readdir(dirPath, {
            withFileTypes: true,
          });

          // Process files and directories separately for better performance
          const files: string[] = [];
          const directories: string[] = [];

          for (const item of items) {
            const itemPath = path.join(dirPath, item.name);

            // Enhanced ignore patterns (in addition to gitignore)
            if (
              item.name.startsWith('.') ||
              item.name === 'node_modules' ||
              item.name === 'dist' ||
              item.name === 'build' ||
              item.name === 'coverage' ||
              item.name === 'target' ||
              item.name === 'bin' ||
              item.name === 'obj' ||
              item.name === '__pycache__' ||
              item.name === '.git' ||
              item.name === '.svn' ||
              item.name === '.hg'
            ) {
              continue;
            }

            // Skip if gitignored (this will now also check gitignore patterns)
            if (isFileIgnored(itemPath)) {
              continue;
            }

            if (item.isDirectory()) {
              directories.push(itemPath);
            } else if (item.isFile()) {
              // Use centralized text extensions
              const ext = path.extname(item.name).toLowerCase();

              if (
                TEXT_EXTENSIONS.has(ext) ||
                (!ext && item.name.indexOf('.') === -1)
              ) {
                files.push(itemPath);
              }
            }
          }

          // Search files in parallel batches for better performance
          const batchSize = 10;
          for (let i = 0; i < files.length; i += batchSize) {
            const batch = files.slice(i, i + batchSize);
            const batchPromises = batch.map(searchInFile);
            const batchResults = await Promise.allSettled(batchPromises);

            for (const result of batchResults) {
              if (result.status === 'fulfilled' && result.value) {
                results.push(result.value);
              }
            }

            // Allow other operations to proceed
            if (i % 50 === 0) {
              await new Promise(resolve => setImmediate(resolve));
            }
          }

          // Search directories recursively
          for (const directory of directories) {
            await searchDirectory(directory, depth + 1);
          }
        } catch (error) {
          console.warn(`Cannot search directory: ${dirPath}`, error);
        }
      };

      // Start the search
      const searchStartTime = Date.now();
      await searchDirectory(folderPath);
      const searchDuration = Date.now() - searchStartTime;

      const searchResults = {
        query: searchQuery,
        totalMatches,
        fileCount: results.length,
        filesSearched,
        filesSkipped,
        searchDuration,
        results: results.sort((a, b) => a.fileName.localeCompare(b.fileName)),
      };

      console.log(
        `‚úÖ Search completed: ${totalMatches} matches in ${results.length} files (${filesSearched} searched, ${filesSkipped} skipped including gitignored) in ${searchDuration}ms`,
      );
      return searchResults;
    } catch (error) {
      console.error('‚ùå Error searching in folder:', error);

      const errorMessage =
        error instanceof Error
          ? error.message
          : typeof error === 'string'
          ? error
          : 'Unknown search error';
      throw new Error(`Failed to search in folder: ${errorMessage}`);
    }
  },
);

// Set zoom level handler
ipcMain.handle('set-zoom-level', async (event, zoomLevel: number) => {
  try {
    if (!mainWindow) {
      console.error('No main window available for zoom');
      return false;
    }

    if (typeof zoomLevel !== 'number' || zoomLevel < 0.5 || zoomLevel > 2.0) {
      throw new Error('Invalid zoom level. Must be between 0.5 and 2.0');
    }

    // Set the zoom level on the main window
    mainWindow.webContents.setZoomFactor(zoomLevel);
    return true;
  } catch (error) {
    console.error('‚ùå Error setting zoom level:', error);
    const errorMessage =
      error instanceof Error
        ? error.message
        : typeof error === 'string'
        ? error
        : 'Unknown zoom error';
    throw new Error(`Failed to set zoom level: ${errorMessage}`);
  }
});

// Helper function to extract all files from complete tree structure
const extractAllFilesFromTree = (
  nodes: FileTreeNode[],
  rootPath: string,
  allFiles: Array<{ name: string; path: string; relativePath: string }> = [],
): Array<{ name: string; path: string; relativePath: string }> => {
  for (const node of nodes) {
    if (node.isDirectory) {
      // Recursively process all children (including background-loaded ones)
      if (node.children && node.children.length > 0) {
        extractAllFilesFromTree(node.children, rootPath, allFiles);
      }
    } else {
      // Add file to collection
      const relativePath = node.path.startsWith(rootPath)
        ? node.path.slice(rootPath.length + 1) // +1 to remove leading slash
        : node.path;

      allFiles.push({
        name: node.name,
        path: node.path,
        relativePath: relativePath,
      });
    }
  }
  return allFiles;
};

// IPC handler to get all files for quick-open functionality
ipcMain.handle('get-all-files-for-quick-open', async () => {
  try {
    // @ts-ignore
    const folderData = store.get(SELECTED_FOLDER_STORE_NAME);

    if (!folderData || !folderData.tree || !folderData.root) {
      return { files: [], folderPath: null, isBackgroundComplete: false };
    }

    // Extract all files from the current tree (initial 2 layers + any background-loaded content)
    const allFiles = extractAllFilesFromTree(folderData.tree, folderData.root);

    return {
      files: allFiles,
      folderPath: folderData.root,
      folderName: folderData.name,
      isBackgroundComplete:
        !folderData.backgroundLoading && !folderData.backgroundLoadingFailed,
      backgroundLoadingFailed: folderData.backgroundLoadingFailed || false,
      totalFiles: allFiles.length,
    };
  } catch (error) {
    console.error('Error getting all files for quick-open:', error);
    return {
      files: [],
      folderPath: null,
      isBackgroundComplete: false,
      error: error instanceof Error ? error.message : 'Unknown error',
    };
  }
});

// Git utility functions
const isGitRepository = async (folderPath: string): Promise<boolean> => {
  try {
    await execAsync('git rev-parse --git-dir', { cwd: folderPath });
    return true;
  } catch (error) {
    return false;
  }
};

const parseGitStatus = (output: string): GitFileStatus[] => {
  const lines = output.split('\n').filter(line => line.trim());
  const files: GitFileStatus[] = [];

  console.log('üîç Parsing Git status output:', { totalLines: lines.length });

  for (const line of lines) {
    // Skip branch status lines that start with ##
    if (line.startsWith('##')) {
      console.log('üìã Skipping branch line:', line);
      continue;
    }

    // Skip lines that are too short to be file status
    if (line.length < 3) {
      console.log('‚è≠Ô∏è Skipping short line:', line);
      continue;
    }

    const stagedChar = line[0];
    const unstagedChar = line[1];
    const filePath = line.substring(3);

    console.log('üìÑ Processing file line:', {
      line,
      stagedChar,
      unstagedChar,
      filePath,
    });

    // Skip if both characters are spaces (shouldn't happen in porcelain format)
    if (stagedChar === ' ' && unstagedChar === ' ') {
      console.log('‚è≠Ô∏è Skipping line with no changes:', line);
      continue;
    }

    // Parse file status
    let status: GitFileStatus['status'] = 'modified';
    let staged = false;

    // Check staged changes first (first character)
    if (stagedChar !== ' ' && stagedChar !== '?') {
      staged = true;
      switch (stagedChar) {
        case 'A':
          status = 'added';
          break;
        case 'M':
          status = 'modified';
          break;
        case 'D':
          status = 'deleted';
          break;
        case 'R':
          status = 'renamed';
          break;
        case 'C':
          status = 'renamed'; // Copied, treat as renamed
          break;
        default:
          status = 'modified';
          console.log('‚ö†Ô∏è Unknown staged status character:', stagedChar);
      }
    }
    // Check unstaged changes (second character)
    else if (unstagedChar !== ' ') {
      staged = false;
      switch (unstagedChar) {
        case 'M':
          status = 'modified';
          break;
        case 'D':
          status = 'deleted';
          break;
        case '?':
          status = 'untracked';
          break;
        case '!':
          status = 'untracked'; // Ignored, treat as untracked
          break;
        default:
          status = 'modified';
          console.log('‚ö†Ô∏è Unknown unstaged status character:', unstagedChar);
      }
    }

    const fileStatus: GitFileStatus = { path: filePath, status, staged };
    files.push(fileStatus);

    console.log('‚úÖ Added file to status:', fileStatus);
  }

  console.log(`üìä Git status parsing complete: ${files.length} files found`);
  return files;
};

const parseGitBranch = (
  output: string,
): { current: string; ahead: number; behind: number } => {
  const lines = output.split('\n');
  let current = 'main';
  let ahead = 0;
  let behind = 0;

  for (const line of lines) {
    if (line.startsWith('##')) {
      const branchInfo = line.substring(3);
      const match = branchInfo.match(/^(\S+)(?:\.\.\.(\S+))?\s*(?:\[(.+)\])?/);

      if (match) {
        current = match[1];
        const trackingInfo = match[3];

        if (trackingInfo) {
          const aheadMatch = trackingInfo.match(/ahead (\d+)/);
          const behindMatch = trackingInfo.match(/behind (\d+)/);

          if (aheadMatch) ahead = parseInt(aheadMatch[1], 10);
          if (behindMatch) behind = parseInt(behindMatch[1], 10);
        }
      }
      break;
    }
  }

  return { current, ahead, behind };
};

// Git IPC Handlers
ipcMain.handle('get-git-status', async (event, folderPath: string) => {
  try {
    console.log('üîç Getting Git status for:', folderPath);

    // Check if it's a Git repository
    const isRepo = await isGitRepository(folderPath);
    if (!isRepo) {
      console.log('üìù Not a Git repository');
      return null;
    }

    // Get git status with branch info
    const { stdout } = await execAsync('git status --porcelain -b', {
      cwd: folderPath,
    });

    console.log('üìã Raw Git status output:');
    console.log(stdout);

    const files = parseGitStatus(stdout);
    const branchInfo = parseGitBranch(stdout);

    const result: GitStatus = {
      files,
      branch: branchInfo.current,
      ahead: branchInfo.ahead,
      behind: branchInfo.behind,
      isClean: files.length === 0,
    };

    console.log(
      `‚úÖ Git status retrieved: ${files.length} files, branch: ${branchInfo.current}`,
    );
    console.log('üìä Final result:', JSON.stringify(result, null, 2));
    return result;
  } catch (error) {
    console.error('‚ùå Error getting Git status:', error);
    throw error;
  }
});

ipcMain.handle('get-git-branch', async (event, folderPath: string) => {
  try {
    console.log('üåø Getting Git branch info for:', folderPath);

    // Check if it's a Git repository
    const isRepo = await isGitRepository(folderPath);
    if (!isRepo) {
      return null;
    }

    // Get detailed branch information
    const { stdout } = await execAsync('git status --porcelain -b', {
      cwd: folderPath,
    });

    const branchInfo = parseGitBranch(stdout);

    // Try to get remote branch info
    let remote: string | undefined;
    try {
      const { stdout: remoteOutput } = await execAsync(
        'git rev-parse --abbrev-ref --symbolic-full-name @{u}',
        {
          cwd: folderPath,
        },
      );
      remote = remoteOutput.trim();
    } catch {
      // No remote branch
    }

    const result: GitBranchInfo = {
      current: branchInfo.current,
      remote,
      ahead: branchInfo.ahead,
      behind: branchInfo.behind,
    };

    console.log(
      `‚úÖ Git branch info: ${result.current} (‚Üë${result.ahead} ‚Üì${result.behind})`,
    );
    return result;
  } catch (error) {
    console.error('‚ùå Error getting Git branch info:', error);
    throw error;
  }
});

ipcMain.handle(
  'git-stage-file',
  async (event, folderPath: string, filePath: string) => {
    try {
      console.log('‚ûï Staging file:', filePath);

      // Use proper quoting for file paths with spaces or special characters
      await execAsync(`git add "${filePath}"`, {
        cwd: folderPath,
      });

      console.log('‚úÖ File staged successfully');
      return { success: true };
    } catch (error) {
      console.error('‚ùå Error staging file:', error);
      throw error;
    }
  },
);

ipcMain.handle(
  'git-unstage-file',
  async (event, folderPath: string, filePath: string) => {
    try {
      console.log('‚ûñ Unstaging file:', filePath);

      // Try modern Git first (Git 2.23+), fallback to older syntax
      try {
        await execAsync(`git restore --staged "${filePath}"`, {
          cwd: folderPath,
        });
      } catch (restoreError) {
        // Fallback to older Git syntax
        await execAsync(`git reset HEAD "${filePath}"`, {
          cwd: folderPath,
        });
      }

      console.log('‚úÖ File unstaged successfully');
      return { success: true };
    } catch (error) {
      console.error('‚ùå Error unstaging file:', error);
      throw error;
    }
  },
);

ipcMain.handle('git-stage-all', async (event, folderPath: string) => {
  try {
    console.log('‚ûï Staging all files');

    await execAsync('git add .', {
      cwd: folderPath,
    });

    console.log('‚úÖ All files staged successfully');
    return { success: true };
  } catch (error) {
    console.error('‚ùå Error staging all files:', error);
    throw error;
  }
});

ipcMain.handle('git-unstage-all', async (event, folderPath: string) => {
  try {
    console.log('‚ûñ Unstaging all files');

    // Try modern Git first (Git 2.23+), fallback to older syntax
    try {
      await execAsync('git restore --staged .', {
        cwd: folderPath,
      });
    } catch (restoreError) {
      // Fallback to older Git syntax
      await execAsync('git reset HEAD', {
        cwd: folderPath,
      });
    }

    console.log('‚úÖ All files unstaged successfully');
    return { success: true };
  } catch (error) {
    console.error('‚ùå Error unstaging all files:', error);
    throw error;
  }
});

ipcMain.handle(
  'git-commit',
  async (event, folderPath: string, message: string) => {
    try {
      console.log('üíæ Committing with message:', message);

      await execAsync(`git commit -m "${message.replace(/"/g, '\\"')}"`, {
        cwd: folderPath,
      });

      console.log('‚úÖ Commit successful');
      return { success: true };
    } catch (error) {
      console.error('‚ùå Error committing:', error);
      throw error;
    }
  },
);

ipcMain.handle('git-push', async (event, folderPath: string) => {
  try {
    console.log('üöÄ Pushing to remote...');

    // Get current branch
    const { stdout: branchOutput } = await execAsync(
      'git branch --show-current',
      {
        cwd: folderPath,
      },
    );
    const currentBranch = branchOutput.trim();

    // Push to origin
    await execAsync(`git push origin ${currentBranch}`, {
      cwd: folderPath,
    });

    console.log('‚úÖ Push successful');
    return { success: true };
  } catch (error) {
    console.error('‚ùå Error pushing:', error);
    throw error;
  }
});

ipcMain.handle('git-pull', async (event, folderPath: string) => {
  try {
    console.log('üì• Pulling from remote...');

    await execAsync('git pull', {
      cwd: folderPath,
    });

    console.log('‚úÖ Pull successful');
    return { success: true };
  } catch (error) {
    console.error('‚ùå Error pulling:', error);
    throw error;
  }
});

ipcMain.handle(
  'git-restore-file',
  async (event, folderPath: string, filePath: string) => {
    try {
      console.log('üîÑ Restoring file to last committed state:', filePath);

      // Try modern Git first (Git 2.23+), fallback to older syntax
      try {
        await execAsync(`git restore "${filePath}"`, {
          cwd: folderPath,
        });
      } catch (restoreError) {
        // Fallback to older Git syntax
        await execAsync(`git checkout -- "${filePath}"`, {
          cwd: folderPath,
        });
      }

      console.log('‚úÖ File restored successfully');
      return { success: true };
    } catch (error) {
      console.error('‚ùå Error restoring file:', error);
      throw error;
    }
  },
);

const createWindow = () => {
  // Create the browser window.
  mainWindow = new BrowserWindow({
    width: 1200,
    height: 800,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    },
    frame: false, // Frameless window
    titleBarStyle: 'hiddenInset',
  });

  // Add error handling for the webContents
  mainWindow.webContents.on('unresponsive', () => {
    console.error('Renderer process became unresponsive');
  });

  mainWindow.webContents.on('responsive', () => {
    console.log('Renderer process became responsive again');
  });

  mainWindow.webContents.on('render-process-gone', (event, details) => {
    console.error('Renderer process gone:', details);
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Open the DevTools.
  mainWindow.webContents.openDevTools();
};

// Set up application menu
const createMenu = () => {
  const { Menu } = require('electron');

  const template: Electron.MenuItemConstructorOptions[] = [
    {
      label: 'File',
      submenu: [
        {
          label: 'Open File or Folder...',
          accelerator: 'CmdOrCtrl+O',
          click: async () => {
            if (mainWindow) {
              mainWindow.webContents.send('menu-open-file');
            }
          },
        },
        {
          label: 'Quick Open File...',
          accelerator: 'CmdOrCtrl+P',
          click: async () => {
            if (mainWindow) {
              mainWindow.webContents.send('menu-quick-open-file');
            }
          },
        },
        { type: 'separator' },
        {
          label: 'Close File',
          accelerator: 'CmdOrCtrl+W',
          click: async () => {
            if (mainWindow) {
              mainWindow.webContents.send('menu-close-file');
            }
          },
        },
        {
          label: 'Close Folder',
          accelerator: 'CmdOrCtrl+Shift+W',
          click: async () => {
            if (mainWindow) {
              mainWindow.webContents.send('menu-close-folder');
            }
          },
        },
        { type: 'separator' },
        {
          label: 'Save File',
          accelerator: 'CmdOrCtrl+S',
          click: async () => {
            if (mainWindow) {
              mainWindow.webContents.send('menu-save-file');
            }
          },
        },
        { type: 'separator' },
        {
          label: 'Quit',
          accelerator: process.platform === 'darwin' ? 'Cmd+Q' : 'Ctrl+Q',
          click: () => app.quit(),
        },
      ],
    },
    {
      label: 'Edit',
      submenu: [
        { role: 'undo' },
        { role: 'redo' },
        { type: 'separator' },
        { role: 'cut' },
        { role: 'copy' },
        { role: 'paste' },
        { role: 'selectAll' },
      ],
    },
    {
      label: 'View',
      submenu: [
        { role: 'reload' },
        { role: 'forceReload' },
        { role: 'toggleDevTools' },
        { type: 'separator' },
        { role: 'resetZoom' },
        { role: 'zoomIn' },
        { role: 'zoomOut' },
        { type: 'separator' },
        { role: 'togglefullscreen' },
      ],
    },
    {
      label: 'Window',
      submenu: [{ role: 'minimize' }, { role: 'close' }],
    },
  ];

  // macOS specific menu adjustments
  if (process.platform === 'darwin') {
    template.unshift({
      label: app.getName(),
      submenu: [
        { role: 'about' },
        { type: 'separator' },
        { role: 'services' },
        { type: 'separator' },
        { role: 'hide' },
        { role: 'hideOthers' },
        { role: 'unhide' },
        { type: 'separator' },
        { role: 'quit' },
      ],
    });

    // Window menu
    template[4].submenu = [
      { role: 'close' },
      { role: 'minimize' },
      { role: 'zoom' },
      { type: 'separator' },
      { role: 'front' },
    ];
  }

  const menu = Menu.buildFromTemplate(template);
  Menu.setApplicationMenu(menu);
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.whenReady().then(() => {
  createMenu();
  createWindow();

  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  app.on('activate', () => {
    if (BrowserWindow.getAllWindows().length === 0) {
      createWindow();
    }
  });
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

// Add global error handlers
process.on('uncaughtException', error => {
  console.error('Uncaught Exception in Main Process:', error);
});

process.on('unhandledRejection', (reason, promise) => {
  console.error('Unhandled Rejection in Main Process:', reason);
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
